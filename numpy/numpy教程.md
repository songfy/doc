本文主要是用来对numpy进行介绍的章节. numpy是python中高性能科学计算是数据分析的基础包, 学会了numpy, 对于我们去理解python中其他机器学习库和数据分析库是非常有帮助的.

我们会详细的介绍numpy的一些基本的知识点, 帮助大家形成自己的技术体系, 我相信大家沿着我的思路来, 都可以成为数据算法的高手.

目录:
1. 构建numpy对象
- 从序列型对象中构造
- 用numpy自带函数构建
2. ndarray的数据类型
3. 索引和切片
- 切片
- 多维索引
- 花式索引
- 布尔索引
4. ufunc通用函数
- ufunc函数的定义和优势
- 自定义ufunc
5. numpy常用的函数
-  数学统计函数
-  改变numpy数据结构的函数
-  where函数
-  线性代数函数
- 排序操作
- 随机数
6. 广播机制
7. matrix对象
8. 数据的持久化


##### 1. 构建numpy对象
引入numpy包:

```
import numpy as np
```

- 从序列型对象中构造

```
a = np.array([1, 2, 3])
print(a)

b = np.array((1, 2, 3))
print(b)
```
输出结果:
```
[1 2 3]
[1 2 3]
```

- 用numpy自带函数构建

```
c = np.zeros(10)
print(c)

d = np.arange(1, 10, 2)
print(d)

e = np.ones((2, 3))
print(e)

f = np.eye(3, 3)
print(f)
```
输出结果为:

```
[ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]

[1 3 5 7 9]

[[ 1.  1.  1.]
 [ 1.  1.  1.]]
 
[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]
```

##### 2. ndarray的数据类型
dtype是ndarray的数据类型, 我们可以看到:

```
print("a", a.dtype)
print("f", c.dtype)
```
输出为:

```
a int32
f float64
```

numpy具有自己推断数据类型的能力, 对于像ones, zeros, eye这样的内置函数, 因为numpy是面对科学计算, 默认都是双精度浮点数类型, 也就是float64.

此外还有别的类型:
- int8, uint8
- int16, uint16
- int32, uint32
- int64, uint64
- float16, float32, float32, float128
- complex64, complex128, complex256
- bool
- object
- string_

我们可以在ndaray构造的时候指定类型:

```
a1 = np.array([2, 3, 4], dtype=np.float64)
print("a1", a1)
print("a1", a1.dtype)
```
输出:

```
a1 [ 2.  3.  4.]
a1 float64
```

也可以进行类型的转换:

```
a2 = a1.astype(dtype=np.int32)
print('a1:', a1.dtype)
print('a2:', a2.dtype)
```
输出:

```
a1: float64
a2: int32
```
**astype默认是copy的, 不会改变原来的数组**.

##### 3. 索引和切片
- 切片

```
print("索引的例子")
a = np.arange(0, 10)
print(a[2])
print(a[1:5])
```
输出:

```
索引的例子
2
[1 2 3 4]
```

**注意:** **切片是视图, 也就是原来数据的引用, 我们对视图的修改会体现在原来的数据上.**

我们来看个例子:

```
print("说明切片是引用")
a[1: 5] = 100
print(a)
```
我们看输出:

```
说明切片是引用
[  0 100 100 100 100   5   6   7   8   9]
```
我们可以用copy函数进行复制数据:

```
print("说明切片是引用")
a[1: 5] = 100
print(a)
print('copy')
a[1: 5].copy()[:] = 10
print(a)
```
输出结果:

```
说明切片是引用
[  0 100 100 100 100   5   6   7   8   9]
copy
[  0 100 100 100 100   5   6   7   8   9]
```

- 多维索引

下面我们来看多维的例子:

```
print("多维的例子:")
b = np.array([[1,2,3], [4,5,6], [7, 8, 9]])
print(b[1])
print(b[2, 2])
```
输出结果:

```
多维的例子:
[4 5 6]
9
```

- 切片索引

```
print(b[1:2])

print(b[1:])

print(b[1:, :2])

print(b[:, :2])

print(b[:, 2])
```
输出结果:

```
[[4 5 6]]

[[4 5 6]
 [7 8 9]]
 
[[4 5]
 [7 8]]
 
[[1 2]
 [4 5]
 [7 8]]
 
[3 6 9]
```
注意最后一个例子, 当我们选定某一维为确定值的时候, 相当于是降了一个维度.

**另外, 高维数组的切片也是一个视图.**

- 花式索引

花式索引:**用整数数组进行索引**.
我们来看一个例子:

```
print("花式索引")
c = np.arange(16).reshape((4,4))
print(c)
d = c[[0, 1, 2]]
print(d)
```
输出结果:

```
花式索引
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
```
注意, 花式索引不是视图, 他会拷贝数据.

```
print("花式索引不是视图")
d[:,:] = 0
print(d)
print(c)
```
输出:

```
花式索引不是视图
[[0 0 0 0]
 [0 0 0 0]
 [0 0 0 0]]
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
```

下面我们来看两行代码:

```
e = c[[0, 2], [0, 2]]
print(e)
```
大家说, 这个我们会输出什么东西?
答案是:

```
[ 0 10]
```
也就是把(0,0), (2,2)的选了出来, 我们其实想要的是矩形区域的数据, 怎么弄呢?

那么下面的语句呢

```
f = c[[[0], [2]], [[0, 2]]]
print(f)
```
答案是:

```
[[ 0  2]
 [ 8 10]]
```
希望大家好好理解这个概念.

- 布尔索引

布尔索引其实就是用bool值来做索引的方式.

```
chars = np.array(['a', 'b', 'c', 'd'])
data = np.arange(16).reshape((4, 4))
print(data[chars == 'a'])

```
输出:

```
[[0 1 2 3]]
```
要注意的是, bool型的也是copy的, 不是视图.

```
data[chars == 'a'][:] = 10
print(data)
```
输出还是:

```
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
```
下面我们来看通过bool索引来做一些方便的功能.
比如, 可以结合bool索引来赋值:

```
data[data > 10] = -1
print(data)
```
输出: 

```
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 -1]
 [-1 -1 -1 -1]]
```
这是, 大家可能会有一个小问题了:

```
h = data[chars == 'a']
h[:] = 10
print(data)

data[chars == 'a'] = 100
print(data)

```
这两次分别是什么输出呢?
答案:

```
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
 
[[100 100 100 100]
 [  4   5   6   7]
 [  8   9  10  11]
 [ 12  13  14  15]]
```
是不是很奇怪呢?
我们可以这么理解, 把用bool索引后再赋值看做是一个操作.


##### 4. ufunc通用函数

- ufunc函数定义以及优势

我们这里开谈谈ufunc, 首先什么是一个ufunc, ufunc的定义:

**对ndarray执行元素级运算的函数.**


我们来看使用ufunc有什么好处:

```
import  numpy as np
import time
import math

b = range(0, 100000)
b = [float(x) for x in b]
begin = time.time()
for _ in range(1000):
    [math.sqrt(x) for x in b]
print("iter cost:", time.time() - begin, "s")

a = np.arange(0, 100000, dtype=np.float64)
begin = time.time()
for _ in range(1000):
    np.sqrt(a)
print("numpy cost:", time.time() - begin, "s")
```
结果是:

```
iter cost: 19.896348476409912 s
numpy cost: 0.22511696815490723 s
```
我们发现, 我们用numpy的效率是用list迭代的效率高得多.


我们可以再看一个二元的运算的例子, 看一个比较少见的例子, mod运算:


```
e = np.arange(0, 1000)
f = np.arange(0, 1000)
r = np.mod(e, f)
print(r)
```

最后结果我们就不用多说了, 全0的数组.

除了这两个, 我们常见的运算符, +, -, *, /, 乘方等都是元素级别的, 我们可以看看:

```
a = np.array([1, 1, 1])
b = np.array([2, 2, 2])
print("a + b:", a + b)
print("a - b:", a - b)
print("(a - b) ** 2:", (a - b) ** 2)
print(" a / b:", a / b)
print("a * b:", a * b)
```
输出结果是:

```
a + b: [3 3 3]
a - b: [-1 -1 -1]
(a - b) ** 2: [1 1 1]
 a / b: [ 0.5  0.5  0.5]
a * b: [2 2 2]
```


- 自定义ufunc
我们可以用函数numpy.frompyfunc和numpy.vectorize把一个普通的python函数变成ufunc, 当然, 这样做的代价是, 这样的ufunc的性能远远不如原生用C写的ufunc.
我们来看一个例子:

```
def my_add(x, y):
    return x + y

add_ufunc = np.frompyfunc(my_add, 2, 1)
x = np.arange(0, 1000000)
y = np.arange(0, 1000000)
begin = time.time()
add_ufunc(x, y)
print("my func cost:", time.time() - begin, "s")
begin = time.time()
np.add(x, y)
print("numpy func cost:", time.time() - begin, "s")
```
输出结果是:

```
my func cost: 0.21407699584960938 s
numpy func cost: 0.003000974655151367 s
```
可见我们自定义的ufunc性能要差多了.

我们来看看我们的返回值是什么类型:

```
print(add_ufunc(x, y).dtype)
```

输出结果为:

```
object
```
我们拿到这个结果还需要做一次类型转换, 似乎非常不方便, 这里会用到另一个方法.

```
add_ufunc = np.frompyfunc(my_add, 2, 1)
add_func2 = np.vectorize(my_add, otypes=[np.int32])
x = np.arange(0, 1000000)
y = np.arange(0, 1000000)

begin = time.time()
add_ufunc(x, y)
print("add_ufunc cost:", time.time() - begin, "s")

begin = time.time()
np.add(x, y)
print("numpy func cost:", time.time() - begin, "s")

begin = time.time()
add_func2(x, y)
print("add_func2 cost:", time.time() - begin, "s")
```
输出结果为:

```
add_ufunc cost: 0.1935279369354248 s
numpy func cost: 0.0020058155059814453 s
add_func2 cost: 0.2732269763946533 s
```
似乎第一种自定义ufunc的性能更好一些.
但是如果我们把类型转换的时间算上呢?

```
def my_add(x, y):
    return x + y

add_ufunc = np.frompyfunc(my_add, 2, 1)
add_func2 = np.vectorize(my_add, otypes=[np.int32])
x = np.arange(0, 1000000)
y = np.arange(0, 1000000)

begin = time.time()
add_ufunc(x, y).astype(dtype=np.int32)
print("add_ufunc cost:", time.time() - begin, "s")

begin = time.time()
np.add(x, y)
print("numpy func cost:", time.time() - begin, "s")

begin = time.time()
add_func2(x, y)
print("add_func2 cost:", time.time() - begin, "s")
```

结果:

```
add_ufunc cost: 0.23007678985595703 s
numpy func cost: 0.003007650375366211 s
add_func2 cost: 0.2823178768157959 s
```

结果差不多, 第一种略好.

##### 5. numpy常用的函数
这一小节应该是最有用的一个小节, 因为介绍的东西是我们后面非常常用的, 在各种地方都会用到这些知识.

- 数学统计函数

我们比较常用的数学统计函数有: sum, mean, std, var, min, max, argmin, argmax, cumsum, cumprod.

大家看到这几个函数虽然不多, 但是都是非常有用的函数.

下面我们来看几个例子:


```
import numpy as np

x = np.arange(0, 12).reshape((4, 3))
print(x)

print("计算总和:")
print(np.sum(x))

print('沿着0方向求和:')
# 输出3的向量
print(np.sum(x, axis=0))

print('沿着1方向求和')
# 输出4的向量
print(np.sum(x, axis=1))


print("计算总平均值:")
print(np.mean(x))

print('沿着0方向求平均:')
# 输出3的向量
print(np.mean(x, axis=0))

print('沿着1方向求平均')
# 输出4的向量
print(np.mean(x, axis=1))


print("计算总标准差:")
print(np.std(x))

print('沿着0方向求标准差:')
# 输出3的向量
print(np.std(x, axis=0))

print('沿着1方向求标准差')
# 输出4的向量
print(np.std(x, axis=1))


print("计算总最大值:")
print(np.max(x))

print('沿着0方向求最大值')
# 输出3的向量
print(np.max(x, axis=0))

print('沿着1方向求最大值')
# 输出4的向量
print(np.max(x, axis=1))

# 累加求和
print(np.cumsum(x, axis=0))

# 如果是bool数组, false是0, true是1
y = np.random.random_integers(0, 100, size=(10, 10))
print(y)
# 计算大于50的有多少个
print((y > 50).sum())
```

输出结果:

```
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
计算总和:
66
沿着0方向求和:
[18 22 26]
沿着1方向求和
[ 3 12 21 30]
计算总平均值:
5.5
沿着0方向求平均:
[ 4.5  5.5  6.5]
沿着1方向求平均
[  1.   4.   7.  10.]
计算总标准差:
3.45205252953
沿着0方向求标准差:
[ 3.35410197  3.35410197  3.35410197]
沿着1方向求标准差
[ 0.81649658  0.81649658  0.81649658  0.81649658]
计算总最大值:
11
沿着0方向求最大值
[ 9 10 11]
沿着1方向求最大值
[ 2  5  8 11]
[[ 0  1  2]
 [ 3  5  7]
 [ 9 12 15]
 [18 22 26]]
[[75  5 56 11 78 82  2 14 72 78]
 [ 2 36  2 62 88 58 49 12 30 58]
 [25  3 35 97 27 49  4 74 45 37]
 [12 61 87 55  0 28 63 55 74 21]
 [27 91 59 31 66 23 88 21 68 54]
 [63 49  6 74 32 48 55 56 21 25]
 [ 9 17  2 52 63 88 31  0 97 67]
 [86 53 83 57 54 54 12 66 77 67]
 [86 11 71 78 94 86 72 92 36 92]
 [27 54 51 12 94 45 38 25  3  5]]
53
```

- 改变numpy数据结构的函数

首先我们要讲的是reshape函数, 其实我们之前已经使用过了, 但是这里我们要补充一点:


```
import numpy as np

# 关于reshape函数, 我们可以用-1方式自适应
a = np.arange(12)

b =  a.reshape((-1, 2))
print(b)
# 输出shape
print(b.shape)

b[:] = 1
print(a)

```
输出:

```
[[ 0  1]
 [ 2  3]
 [ 4  5]
 [ 6  7]
 [ 8  9]
 [10 11]]
(6, 2)
[1 1 1 1 1 1 1 1 1 1 1 1]

```
注意到, **-1可以表示自适应**, 另外**reshape也是视图**. shape字段是个tuple, 表示数组的尺寸.

下面我们来看怎么把数组拉平, ravel不产生副本, flattern产生副本. 我们来看:

```
a = np.arange(1, 10).reshape((3, 3))
c = np.ravel(a)
print("ravel:", c)
c[:] = 1
print(a)

a = np.arange(1, 10).reshape((3, 3))
c = a.flatten()
print("flatten:", c)
c[:] = 1
print(a)
```
输出结果:

```
ravel: [1 2 3 4 5 6 7 8 9]
[[1 1 1]
 [1 1 1]
 [1 1 1]]
flatten: [1 2 3 4 5 6 7 8 9]
[[1 2 3]
 [4 5 6]
 [7 8 9]]
```
我们可以看到, **ravel返回的是视图, flatten返回的是副本**.

注意, 这里orde默认是'C', 也就是按照行的顺序, 我们也可以选择'F', 按照列的顺序.


```
print("按照列的顺序进行flatten:")
a = np.arange(1, 10).reshape((3, 3))
c = a.flatten(order='F')
print("flatten:", c)

```
输出结果为:

```
按照列的顺序进行flatten:
flatten: [1 4 7 2 5 8 3 6 9]
```

下面我们来讲几个使用的数组分拆和合并的函数. 这个在我们图像处理中也是非常常见.


```
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6], [7, 8]])
# 沿着0方向合并, 相当于是vstack
c = np.concatenate([a, b], axis=0)
print("沿着0方向合并:\n", c)
# 沿着1方向合并, 相当于是hstack
c = np.concatenate([a, b], axis=1)
print("沿着1方向合并:\n", c)

c = np.vstack([a, b])
print("vstack:\n", c)

c = np.hstack([a, b])
print("hstack:\n", c)
```
输出结果为:

```
沿着0方向合并:
 [[1 2]
 [3 4]
 [5 6]
 [7 8]]
沿着1方向合并:
 [[1 2 5 6]
 [3 4 7 8]]
vstack:
 [[1 2]
 [3 4]
 [5 6]
 [7 8]]
hstack:
 [[1 2 5 6]
 [3 4 7 8]]
```

下面我们来看split, 这个概念比较抽象, 但是我们需要仔细思考, 我们可以看这个函数的说明:

```
 Split an array into multiple sub-arrays.

    Parameters
    ----------
    ary : ndarray
        Array to be divided into sub-arrays.
    indices_or_sections : int or 1-D array
        If `indices_or_sections` is an integer, N, the array will be divided
        into N equal arrays along `axis`.  If such a split is not possible,
        an error is raised.

        If `indices_or_sections` is a 1-D array of sorted integers, the entries
        indicate where along `axis` the array is split.  For example,
        ``[2, 3]`` would, for ``axis=0``, result in

          - ary[:2]
          - ary[2:3]
          - ary[3:]

        If an index exceeds the dimension of the array along `axis`,
        an empty sub-array is returned correspondingly.
    axis : int, optional
        The axis along which to split, default is 0.

    Returns
```

说人话是什么意思呢, 意识是说, 我们这个函数是用来分割数组的, 怎么分, 根据indices_or_sections来分, 
如果indices_or_sections是整数N, 就分割成N段.如果indices_or_sections是个1的数组, 则每个值都是一个分割
点, 该分割点是后一段的起点.

这样就很清楚了吧, 我们来看看代码.


```
a = np.ones(shape=[4, 6])
print(a)
split_arr = np.split(a, 3, axis=1)
print(split_arr)

# [4, 1], [4, 4], [4, 1]
split_arr = np.split(a, [1, 5], axis=1)
print(split_arr)
```
输出结果为:

```
[[ 1.  1.  1.  1.  1.  1.]
 [ 1.  1.  1.  1.  1.  1.]
 [ 1.  1.  1.  1.  1.  1.]
 [ 1.  1.  1.  1.  1.  1.]]
[array([[ 1.,  1.],
       [ 1.,  1.],
       [ 1.,  1.],
       [ 1.,  1.]]), array([[ 1.,  1.],
       [ 1.,  1.],
       [ 1.,  1.],
       [ 1.,  1.]]), array([[ 1.,  1.],
       [ 1.,  1.],
       [ 1.,  1.],
       [ 1.,  1.]])]
[array([[ 1.],
       [ 1.],
       [ 1.],
       [ 1.]]), array([[ 1.,  1.,  1.,  1.],
       [ 1.,  1.,  1.,  1.],
       [ 1.,  1.,  1.,  1.],
       [ 1.,  1.,  1.,  1.]]), array([[ 1.],
       [ 1.],
       [ 1.],
       [ 1.]])]
```

- where函数

这个where函数也是很重要的一个函数, 我们这里仔细讲解一下.

我们可以看一个简单的例子:

```
import numpy as np

a = np.arange(0, 16).reshape((4, 4))
b = np.where(a > 10, 1, 0)
print(b)
```
输出为:

```
[[0 0 0 0]
 [0 0 0 0]
 [0 0 0 1]
 [1 1 1 1]]

```
另外, 这里的1和0都可以是数组:

```
import numpy as np

a = np.arange(0, 16).reshape((4, 4))
b = np.where(a > 10, a, 0)
print(b)
```
输出为:

```
[[ 0  0  0  0]
 [ 0  0  0  0]
 [ 0  0  0 11]
 [12 13 14 15]]
```
我们可以带入更复杂的条件表达式:

```
import numpy as np

a = np.arange(0, 16).reshape((4, 4))
b = np.where((a > 10) & (a <= 13), a, 0)
print(b)
```
输出为:

```
[[ 0  0  0  0]
 [ 0  0  0  0]
 [ 0  0  0 11]
 [12 13  0  0]]
```
我们可以通过用where函数, 构造出非常复杂的表达式.



- 线性代数函数

下面我们来过几个线性代数的函数, 这个太简单了, 我们就在代码里看吧.

```
import numpy as np
from numpy import linalg

# 矩阵相乘dot
print('矩阵相乘dot')
a = np.array([[1, 2]])
b = a.T
print(np.dot(a, b))
print(np.dot(b, a))

# 求行列式
print('求行列式')
c = np.dot(b, a)
print(linalg.det(c))

# 求trace
print('求trace')
c = np.dot(b, a)
print(np.trace(c))

# 计算矩阵的逆矩阵
print("计算矩阵的逆矩阵")
a = np.array([[1, 2], [3, 4]])
print(linalg.inv(a))
print(a.dot(linalg.inv(a)))

# 求特征值
print("特征值")
l,n = linalg.eig(a)
print(l)
print(linalg.inv(n).dot(a).dot(n))

# 求解线性方程组
print('求解线性方程组')
print(linalg.solve(a, [[1], [1]]))
```

输出为:


```
矩阵相乘dot
[[5]]
[[1 2]
 [2 4]]
求行列式
0.0
求trace
5
计算矩阵的逆矩阵
[[-2.   1. ]
 [ 1.5 -0.5]]
[[  1.00000000e+00   1.11022302e-16]
 [  0.00000000e+00   1.00000000e+00]]
特征值
[-0.37228132  5.37228132]
[[ -3.72281323e-01   6.10622664e-16]
 [  4.44089210e-16   5.37228132e+00]]
求解线性方程组
[[-1.]
 [ 1.]]
```

- 排序操作

排序是计算机里面非常重要的一个主题, 我们在数据结构中会学到大量的排序算法, 这里我们主要来看看numpy中是怎么做排序的.

我们可以看一个简单的例子:

```
import numpy as np

# 生成一个随机数数组
a = np.random.randn(10)
print("排序前:")
print(a)

print("排序后:")
a.sort()
print(a)
```
我们得到的结果为:

```
排序前:
[ 0.25961162 -1.10765802 -0.14011338  0.07128947  0.42158243  0.2042486
  2.13969595 -0.8757201  -0.89578139  0.29393567]
排序后:
[-1.10765802 -0.89578139 -0.8757201  -0.14011338  0.07128947  0.2042486
  0.25961162  0.29393567  0.42158243  2.13969595]
```

我们现在要进一步来讨论一下按照某个轴来排序:


```
print("按照某一个轴来排序:")
b = np.random.randn(5, 4)
c = b.copy()
print(b)
print("按照0轴来排序:")
b.sort(0)
print(b)
c.sort(1)
print("按照1轴来排序:")
print(c)
```

输出结果为:

```
按照某一个轴来排序:
[[-0.27559906 -0.20935794  1.11878329 -0.22389089]
 [ 0.75192884 -0.91481694  0.24864103 -0.1466624 ]
 [ 1.22577567  1.34879153 -2.42137535 -0.89293982]
 [ 0.18263706 -0.32259292  0.12092114 -0.51071113]
 [ 0.4952625  -1.32498593 -0.49722838 -0.92038718]]
按照0轴来排序:
[[-0.27559906 -1.32498593 -2.42137535 -0.92038718]
 [ 0.18263706 -0.91481694 -0.49722838 -0.89293982]
 [ 0.4952625  -0.32259292  0.12092114 -0.51071113]
 [ 0.75192884 -0.20935794  0.24864103 -0.22389089]
 [ 1.22577567  1.34879153  1.11878329 -0.1466624 ]]
按照1轴来排序:
[[-0.27559906 -0.22389089 -0.20935794  1.11878329]
 [-0.91481694 -0.1466624   0.24864103  0.75192884]
 [-2.42137535 -0.89293982  1.22577567  1.34879153]
 [-0.51071113 -0.32259292  0.12092114  0.18263706]
 [-1.32498593 -0.92038718 -0.49722838  0.4952625 ]]
```

下面我们来讨论一下关于是视图还是副本的问题. 这个问题很重要, 首先, 我们不难发现, a.sort()

这个函数, 一定是视图, 我想大家可以从调用形式上就可以发现, 那么有没有副本呢?

有的, 我们来看:


```
print("验证是否是副本:")
a = np.random.randn(5, 4)
c = np.sort(a, axis=0)
print(c)
c[:] = 0
print(c)
print(a)
```
输出结果为:

```
验证是否是副本:
[[-1.9407303  -1.7950289  -0.36422007 -0.81554144]
 [-0.48054314 -0.67041844 -0.32452217 -0.54827715]
 [-0.19745229  0.08656735 -0.14355933 -0.20606166]
 [ 0.48031298  0.30377625  0.3622024   0.20087184]
 [ 1.84449922  1.74493341  0.7219248   0.28360284]]
[[ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]]
[[-1.9407303   0.30377625 -0.36422007 -0.81554144]
 [-0.19745229  0.08656735 -0.32452217  0.20087184]
 [-0.48054314  1.74493341  0.3622024  -0.54827715]
 [ 0.48031298 -0.67041844 -0.14355933  0.28360284]
 [ 1.84449922 -1.7950289   0.7219248  -0.20606166]]

```

**np.sort确实会拷贝数据.**

ok, 现在有人会问, 怎么降序排列? numpy没有提供直接的参数可以降序排列, 但是,

我们与索引啊:


```
print("降序排序:")
b = np.random.randn(5, 4)
b.sort(0)
print(b[::-1, :])
```

我们来看输出的结果:


```
降序排序:
[[ 0.6260786   1.56956287  0.84155177  1.38056907]
 [ 0.43383513  0.75973095 -0.03726721  0.36198725]
 [-0.15135546  0.3486834  -0.67966072  0.18398989]
 [-0.15449549  0.05453104 -1.29553146  0.0998419 ]
 [-1.17619836 -1.11086607 -1.73212174 -1.83950348]]
```

是不是超级简单.

我们发现上面的排序, 都是**每行或者是每列分别排序**, 怎么能够做到按照某一行或者某一列来排序呢?

```
print("按照第一行来排列:")
index = np.argsort(b[0])
print(index)
print(b[:, index])
```
输出结果为:

```
[2 0 1 3]
[[-2.17054485 -1.5930237  -1.10378898 -0.96218619]
 [-0.40794713 -0.52758218 -0.77104496 -0.77324025]
 [ 0.00906067 -0.09218014 -0.53336505 -0.67395581]
 [ 1.02367673 -0.04342621  0.77833616 -0.48417677]
 [ 1.26704808  1.12892381  0.81186384  1.27139182]]
```

我们来看看下面一个例子:


```
print("我们用了花式索引, 因此是copy")
c = b[:, index]
c[:] = 1
print("c:", c)
print("b:", b)
```

输出结果为:


```
我们用了花式索引, 因此是copy
c: [[ 1.  1.  1.  1.]
 [ 1.  1.  1.  1.]
 [ 1.  1.  1.  1.]
 [ 1.  1.  1.  1.]
 [ 1.  1.  1.  1.]]
b: [[-1.15672892 -0.52296719 -0.03034771 -0.15770518]
 [-0.91799524  0.48075544  0.28511172 -0.13429204]
 [-0.47051477  0.52805344  0.8567386   0.12833422]
 [ 0.08007261  0.70318544  1.07134006  0.67388316]
 [ 0.39340377  2.22354376  1.81761902  1.08321586]]
```

**注意到我们通过c得到b的一个既有花式索引又有切片的, 我们去改变c的值, 我们发现,**

**b的值没有被改变, 因此我们可以说, 这里c因为花式索引, 是b的一个拷贝,**

**表示按照b的第一行升序排列, 我们改变c的值, b的值不变, 因为是拷贝.**

另外, 我们可以选择排序算法的种类, 我们在数据结构中学到过很多的排序算法, 我们在sort的时候都可以选择:


```
kind : {'quicksort', 'mergesort', 'heapsort'}, optional
                Sorting algorithm. Default is 'quicksort'.
```

这是kind的参数的选择, 我们可以选择任意的一种.


```
a = np.random.randn(10)
a.sort(kind='mergesort')
print(a)
```

 输出:
 
 
```
[-1.06064353 -0.93025243 -0.59425919 -0.44945696 -0.30969112  0.15160111
  0.43299713  0.81999085  0.84239351  1.1186306 ]
```

- 随机数

我们两看看numpy中的随机数, 


```
import numpy as np

# 演示一下numpy的随机数

# 产生一个0到1上的均匀分布
a = np.random.rand(2, 3)
print(a)

# 产生一个标准正态分布
b = np.random.randn(2, 3)
print(b)

# 产生一个[`low`, `high`)上的均匀分布
c = np.random.randint(1, 101, size=(2, 3))
print(c)

# 这个函数很有意思, 可以用来随机抽样
# 我们来来看看这个函数的用法

# 从0到9中抽取100个
d = np.random.choice(10, size=(100))
print(d)

# 从0到9999中均匀采样的另一种实现方式
samples = np.arange(0, 10000)
prob = np.ones(10000) / 10000
e = np.random.choice(samples, size=(1000), p=prob)
print(e)
```

输出结果为:

```
[[ 0.74706003  0.31655053  0.15232242]
 [ 0.64792753  0.49001896  0.92514152]]
[[ 0.42573167  1.0608461   0.46147471]
 [-0.01029309 -0.83696533  0.19086798]]
[[62 20 52]
 [96 64 55]]
[6 7 2 1 0 2 6 6 3 3 0 8 4 4 8 4 5 4 2 0 5 2 2 4 6 6 9 6 7 3 3 2 6 7 2 2 1
 3 3 8 6 1 0 5 7 6 1 9 7 0 9 1 7 9 7 0 1 2 9 4 0 5 9 3 5 4 1 5 9 7 4 1 1 3
 0 1 3 6 9 9 6 1 5 7 7 3 8 6 9 7 3 9 0 8 2 9 7 9 4 2]
[1610 8101  732 3595 2651 6300  777 4257 8566 5118 5765 5332 2202 2277 4547
 5696  866 6714 2868   62 6477 3814 3631 6062 9111 9812 3887  447 1796 3180
 3787 6508 4851 2527 2405 9526 9652 5248 9980 1251 3799 2530 6788  569 5031
 4133 3207 6754 3636 6009 1134 9379 4761 8828 4227 2426 4796 9597 8728 7999
 6812 6525 8989 5605 5580 4383  817   62 2293 9045 5941 5235 1007  582 3800
 8700  883 4689 4584 7247 3131 7707 1910 4552 6353  504 1548 4181 5419 2557
 6263 3973 5227  376 9433 2558 5726 9434 7513 5293 3376 7871 5251 4330 7043
 4117  591  765 2877 1148 3753 4952 3902 2805  200 8692 1314 9823 5198 6872
 9515 6534 5459 6910 6200 9642 4996 9617 1327 7792 4565 3183 3382 3362   55
 4739 1772 2872 7276 7712 9759 8845 6164 1770 7116 5389 9191 1489 4820 5429
 1695 2317 5057   69 4070 2386 1091  305 1491  756 3129 1367 8813 5777 9876
 1831 1344 9789 4924 2988 9734  482 5690 5735 4402 3389 3129 5421 7322 8529
 3841 4774 4061  678 6134 9531 4358 7847 4528 6735 1630 2718 7600 9546 6926
 5260  909 5800 4007  993 1374  211 4866 5126 3388 4039 3330 9949 3388   58
  469   10 1034 5822 5580 9334 6331 2191 5641 9557 1919 3764 4963 2906 7623
 1762 7067 3593 3922 7070 2699 3173 1541 2513 9208 4698 7532  206    2 3497
 6020 6099 6527 4879 6639 1550 4562 7710 3233 1408 3601 7432 7915 9807 8262
 2238  773 7930 3519 1013 1865 3683 6302 8645 1154 7150  900 6870 3541 9592
 4878 2046 1179 2634 3144 8015  725 2821 5445 1187  127 5044 5781 8561 7692
 8464  675 9836 3495  721 2939 5673 6214 7459 7096   78 6272 7073 8309 9390
 4596 4159   22 3769 3911 4085  101 3831 9370 5096 6922  885 9527 4062 5789
 8129  434 3805 2093 7001 6396 1448 7515  367 2856 7451 8777 4385 3916 9838
 7827 7238  402 5238    6 2248 7798  937 1298 8719  680 6170 4459 2944 4026
 1287 7707 6836 9330   27 6985 8837   54 8932 7509 7788 4789 9164 8987    8
 3922 7476 5413 4994 6729  461 2093 9321 4315 8032 5666  198 7158  164 7769
 7630 9707 1483  886 2097 6707 1777 4389 1531 9997 5922 9454 6656 7290 2471
 7338 6800 9044 7354 6898 6476 2362 1718 7688 7888 1857 8078 2895 9481 2461
 9374 1220 5819 2295 3231 4260 1783  404 4703 5598 4533 6324 6312 6449 4795
 5279 7557 5283 2595 3138  477 7392 7865 8180 5884 4488 4996 1003 1248 6245
 7593 1270 5198 1102 5628 1880  329 5563 2848 5462 6738 5788 9747 8790 9016
 7895 6023 9356 9231 8131 7880 1805 1852 9847 9861  436 8692 5082 5025 6814
 7489 7281 8365 3175 4012 3980 4634 2062 3891 3346 5146  408 2475  891 8145
 3805 9929 1198 1214 9879 7620 5149 5438  100 3491 2193 7754 1899 3359 2871
 5552 5588  146 3268 4259 2425 3986 8386 4488 3355 3126 6438 7279 8194 5726
 2001 6050 5343 2156 7778 6870 9607 4641 9833 7441 5858 1666 5547 2811 1840
 6520 2585 9165 5960 2159 5326 5941 8275 6844 1340 5988 1397 9218 6914 5538
 4505 3485 5727 3086 3429  392  930 4258 8138 3135 3508 2270 8228 5722 5683
 2386 4994 2351 5438  351 5287 3925 2592 8388 4533 5860  536 7670 4515 3505
 1594 6558 3514 7813 5310  770 7578 9442 7480 7565 9215 9264 9314 6549 7561
 3438 1632 4921  624 9948 2576 3997  744  234 6997 9588 3223 2584 2889 4707
 7701 6959 7773 6602 8474 1306 6769 6027 7385 2840  314 7176 8001 6628 1929
 4583 9392  350 5595  973 3700  929 9940 9418 9484 2471 5408 8677 2168 5755
 5422 6139 6013  970  790 7215 9546 8029 6409 5103 8113 2575 3989   13 3475
 7767 4028 5891 7729 9967 7000 1595 6644 8906 3393 1453 1572 6119 1935 5186
 2392 5645 9170 1429 3188 7669 5106 8021 1034 8482 3945 4401 6956 7581 6806
 9063 9208 1578 6389 6712 4899 6196 8460 5267 2612 2921 8291 1144 9172 5905
 7521 1676 4438   82 7243 5674 2984 8051 7008 3805 8940 5087 6197 7798 7400
 1340 7945 5297 9914 9692 2832 2649 8372 1625 2522 6406 3658 2230 5360 1057
 1739 2490 2198 9433 8727 2184  768 4346 5588 4021 5965 2416  566 3272 2727
 2823 8096 4426 6942 8500 2623 3592 2609 9370 6096 9817 1902 3283 8292 7554
 3704 4962 1519 2894  824 7726 5928 8694 8472 4474 6528 5404 9830 2487 2162
 1476 1565 4739 1275 3326  360 8737 6889 1219 4940 3594 4100 7226 6135 1668
 3312 2224 9241 1750 2300 2979   27 9725 5606 5504 1701 6524 2956 9433 7791
 2433 8092 4597 2952 8399 8153 7249 7261 6583 1136 5763 8061 6729 5200 7857
  849 1869  613 8588 8405 6486 7574 8330 3422 9237 9292 7800 9037 4145 6180
 4423 8731 1461  633 1702 9458 8744 5683 6545 9544 5988 2663 3431 6630 6051
 7210 8814 9779 3760 7438 7023 3551 4901 1719 5877 1268 3235 3301 8408 3436
 7069 8619 2227 5782 9133 4360 8613 4911 3554 9426  433 2989 8555 6536 4651
 3067 2619  156 4637 5147  768 3398 9675 5008 4090 9414 5751  233 3008 9908
 9699 5979 3011 7777 2941 6320  439 9792 2804 7495 6934 5602 1737   98 4336
 9107 8360 3525 8415 2232 6618 8776 7902 7720 7235 9260 4797  436 9111 6602
 9691 1934 7418 6139  324 7289 5599 2995 4611  830 9420  633 6926 4919  818
 8334 3667 1436 8779 9061 2971 1780 9052 9761 2866 9239 8877 4576 9187 9258
  231 5630  678 1904 8485 5103 8036 1516 1910 9674 3240 3009 7336 1086 1771
 8169 1554 1616 9370 4708 2366 5565 4558  808 6950 8373 8105 8175 7701 2429
 8684 7161 5796 2582 9865 8333 2773 9754 2078 2634 9200 6516 7399 1624 7981
 8099 1653 5040 7051 1495 9584 7260 7497 2931 3456]
```

##### 6. 广播机制

这个是一个非常重要的概念, 很多同学在看python代码的时候, 都会对这个广播机制感到不适应, 这个我们需要详细来讨论讨论.

首先我们来看, 

下面我们来谈谈numpy中的广播机制.

首先, 我们来说一下广播的原则:

**如果两个数组的tailing dimension相同, 或者其中一方的为1, 那么广播会在缺失和长度为1的维度上进行.**

如何来理解这句话呢?

我们看几个例子, 

比如(3, 4, 5, 6) 和 (4, 5, 6), 广播会发生吗?
会, 会在第0维上进行.

(3, 4, 5, 6)和(5, 6)呢. 也会, 广播会在第0和第1维上进行.

(3,4, 5, 6)和(4, 1, 6)呢, 广播会在第0, 和第2维上进行.

(3,4, 5, 6)和(4, 1, 1)呢, 广播会在第0, 第2, 第3维度上进行.

(3, 4, 5, 6)和(1, 5, 1)呢, 也可以

最后, (3, 4, 5, 6)和(1, 4, 5)呢, 不行, 因为并不是tailing dimension, 所谓tailing dimension就是从尾部开始计算.

我们来看几个例子:


```
import numpy as np

# 我们来说明一下广播的例子

print("例子1:")
a = np.zeros(shape=(3, 4, 5, 6))
b = np.ones(shape=(4,5,6))
print(a + b)

print("例子2:")
a = np.zeros(shape=(3, 4, 5, 6))
b = np.ones(shape=(5,6))
print(a + b)

print("例子3:")
a = np.zeros(shape=(3, 4, 5, 6))
b = np.ones(shape=(4,1, 6))
print(a + b)

print("例子4:")
a = np.zeros(shape=(3, 4, 5, 6))
b = np.ones(shape=(1,5, 1))
print(a + b)

print("例子5:")
a = np.zeros(shape=(3, 4, 5, 6))
b = np.ones(shape=(1,4, 5))
print(a + b)
```

输出为:


```
例子1:
[[[[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]]


 [[[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]]


 [[[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]]]
例子2:
[[[[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]]


 [[[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]]


 [[[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]]]
例子3:
[[[[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]]


 [[[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]]


 [[[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]]]
例子4:
[[[[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]]


 [[[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]]


 [[[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]

  [[ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]
   [ 1.  1.  1.  1.  1.  1.]]]]
例子5:
Traceback (most recent call last):
  File "D:/code/git/data_basics/numpy_broadcast.py", line 28, in <module>
    print(a + b)
ValueError: operands could not be broadcast together with shapes (3,4,5,6) (1,4,5) 
```

下面我们看几个更复杂的例子, 我们从计算平均值开始来说:


```
a = np.random.randn(4, 3)
x = a.mean(axis=0)
print(a.shape, ":", x.shape)
# 可以进行相减
print(a - x)

y = a.mean(axis=1)
print(a.shape, ":", y.shape)
# tailing dimension不一致, 怎么办呢
# 加一个维度
y = a.mean(axis=1)[:, np.newaxis]
print(a.shape, ":", y.shape)
print((a - y).mean(axis=1))

# 我们可以看更复杂的3维的例子
print("三维的例子:")
a = np.random.randn(4, 3, 2)
x = a.mean(1)[:, np.newaxis, :]
print((x-a).mean(1))
```

我们可以看到输出结果为:


```
(4, 3) : (3,)
[[ 0.06824341 -1.84361314  1.5173392 ]
 [-0.33843114  0.75880688 -1.23353768]
 [ 0.27439765  1.08882413 -1.39801169]
 [-0.00420992 -0.00401787  1.11421017]]
(4, 3) : (4,)
(4, 3) : (4, 1)
[  0.00000000e+00   7.40148683e-17   0.00000000e+00  -3.70074342e-17]
三维的例子:
[[  0.00000000e+00   0.00000000e+00]
 [ -4.62592927e-17   3.70074342e-17]
 [  0.00000000e+00  -7.40148683e-17]
 [  0.00000000e+00  -7.40148683e-17]]
```

对于赋值, 也是这个原理:


```
# 赋值的广播也是一个原理
a = np.ones(shape=(4, 3))
b = np.zeros(4)

print(a)
print(b)

a[:] = b[:, np.newaxis]
print(a)
```

输出结果为:


```
[[ 1.  1.  1.]
 [ 1.  1.  1.]
 [ 1.  1.  1.]
 [ 1.  1.  1.]]
[ 0.  0.  0.  0.]
[[ 0.  0.  0.]
 [ 0.  0.  0.]
 [ 0.  0.  0.]
 [ 0.  0.  0.]]
```

##### 7. matrix对象

这里要介绍一个比较独特的对象, 就是matrix对象, 这个对象比较特别, 我们来看看这个对象:


```

x = np.array([[1, 2], [3, 4]])
X = np.matrix(x)

print(type(x))
print(type(X))

y = np.asarray(X)
print(type(y))
print(y)
```

输出为:


```
<class 'numpy.ndarray'>
<class 'numpy.matrixlib.defmatrix.matrix'>
<class 'numpy.ndarray'>
[[1 2]
 [3 4]]
```


我们再来看几个例子:


```
y = np.asarray(X)
print(type(y))
print(y)

# matrix和ndarray的不同
print("matrix和ndarray的不同")
# 我们来看索引
print(x[:, 1]) # 变成了1d的数组
print(X[:, 1]) # 是2x1的矩阵

print(x[:, 1] * x[1, :]) # 元素级别相乘
print(X[:, 1] * X[1, :]) # 矩阵相乘

# 矩阵的运算
# 计算逆矩阵
print(X.getI())

# 计算转秩
print(X.getT())

# 计算行列式
print(np.linalg.eig(X))

print(np.linalg.inv(X))

print(X*X)

```

输出:


```
matrix和ndarray的不同
[2 4]
[[2]
 [4]]
[ 6 16]
[[ 6  8]
 [12 16]]
[[-2.   1. ]
 [ 1.5 -0.5]]
[[1 3]
 [2 4]]
(array([-0.37228132,  5.37228132]), matrix([[-0.82456484, -0.41597356],
        [ 0.56576746, -0.90937671]]))
[[-2.   1. ]
 [ 1.5 -0.5]]
[[ 7 10]
 [15 22]]
[[ 7 10]
 [15 22]]

```

如果有大量线性运算, 可以先转换为matrix, 再转换为ndarray.


##### 8. 数据的持久化

我们接下来看看numpy的持久化问题.


```
import numpy as np

a = np.array([[1, 2], [2, 3]])
np.save("a", a)

b = np.load("a.npy")
print(b)

# 我们可以保存多个数组
e = np.arange(10).reshape((-1, 5))
f = np.arange(10).reshape((-1, 10))

np.savez('z',e=e, f=f)

arr = np.load("z.npz")

print(arr['e'], arr['f'])

# 我们也可以保存成一个txt文件

np.savetxt("e.txt", e, delimiter=",")

t = np.loadtxt("e.txt", delimiter=",")

print(t)
```

输出结果为:


```
[[1 2]
 [2 3]]
[[0 1 2 3 4]
 [5 6 7 8 9]] [[0 1 2 3 4 5 6 7 8 9]]
[[ 0.  1.  2.  3.  4.]
 [ 5.  6.  7.  8.  9.]]
```
